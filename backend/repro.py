from iree import compiler#, runtime as rt
# rt.flags.parse_flags("--task_topology_group_count=8")

# CODE = """
# #loc0 = loc(unknown)
# module @jit_prim_fun.12 {
#   func.func public @main(%arg0: tensor<1x1xi32> loc(unknown), %arg1: tensor<1xi32> loc(unknown), %arg2: tensor<1xi32> loc(unknown)) -> tensor<1x1xi32> {
#     %0 = "mhlo.scatter"(%arg0, %arg1, %arg2) ({
#     ^bb0(%arg3: tensor<i32> loc(unknown), %arg4: tensor<i32> loc(unknown)):
#       "mhlo.return"(%arg4) : (tensor<i32>) -> () loc(#loc1)
#     }) {indices_are_sorted = true, scatter_dimension_numbers = #mhlo.scatter<update_window_dims = [0], inserted_window_dims = [1], scatter_dims_to_operand_dims = [1]>, unique_indices = true} : (tensor<1x1xi32>, tensor<1xi32>, tensor<1xi32>) -> tensor<1x1xi32> loc(#loc1)
#     return %0 : tensor<1x1xi32> loc(#loc0)
#   } loc(#loc0)
#   } loc(#loc0)
# #loc1 = loc("jit(scatter)/jit(main)/scatter[update_consts=() dimension_numbers=ScatterDimensionNumbers(update_window_dims=(0,), inserted_window_dims=(1,), scatter_dims_to_operand_dims=(1,)) indices_are_sorted=True unique_indices=True mode=GatherScatterMode.FILL_OR_DROP]"("/Users/birch/anaconda3/envs/torch-nightly/lib/python3.9/site-packages/transformers/models/bart/modeling_flax_bart.py":926:1))
# """

# CODE = """
# #loc0 = loc(unknown)
# module @jit__threefry_split.11 {
#   func.func public @main(%arg0: tensor<2xui32> loc(unknown)) -> tensor<2x2xui32> {
#     %0 = "mhlo.iota"() {iota_dimension = 0 : i64} : () -> tensor<4xui32> loc(#loc1)
#     %1 = "mhlo.slice"(%arg0) {limit_indices = dense<1> : tensor<1xi64>, start_indices = dense<0> : tensor<1xi64>, strides = dense<1> : tensor<1xi64>} : (tensor<2xui32>) -> tensor<1xui32> loc(#loc2)
#     %2 = "mhlo.reshape"(%1) : (tensor<1xui32>) -> tensor<ui32> loc(#loc3)
#     %3 = "mhlo.slice"(%arg0) {limit_indices = dense<2> : tensor<1xi64>, start_indices = dense<1> : tensor<1xi64>, strides = dense<1> : tensor<1xi64>} : (tensor<2xui32>) -> tensor<1xui32> loc(#loc4)
#     %4 = "mhlo.reshape"(%3) : (tensor<1xui32>) -> tensor<ui32> loc(#loc3)
#     %5 = "mhlo.slice"(%0) {limit_indices = dense<2> : tensor<1xi64>, start_indices = dense<0> : tensor<1xi64>, strides = dense<1> : tensor<1xi64>} : (tensor<4xui32>) -> tensor<2xui32> loc(#loc5)
#     %6 = "mhlo.slice"(%0) {limit_indices = dense<4> : tensor<1xi64>, start_indices = dense<2> : tensor<1xi64>, strides = dense<1> : tensor<1xi64>} : (tensor<4xui32>) -> tensor<2xui32> loc(#loc6)
#     %7 = mhlo.xor %2, %4 : tensor<ui32> loc(#loc7)
#     %8 = mhlo.constant dense<466688986> : tensor<ui32> loc(#loc8)
#     %9 = mhlo.xor %7, %8 : tensor<ui32> loc(#loc7)
#     %10 = "mhlo.broadcast_in_dim"(%2) {broadcast_dimensions = dense<> : tensor<0xi64>} : (tensor<ui32>) -> tensor<2xui32> loc(#loc9)
#     %11 = mhlo.add %5, %10 : tensor<2xui32> loc(#loc9)
#     %12 = "mhlo.broadcast_in_dim"(%4) {broadcast_dimensions = dense<> : tensor<0xi64>} : (tensor<ui32>) -> tensor<2xui32> loc(#loc9)
#     %13 = mhlo.add %6, %12 : tensor<2xui32> loc(#loc9)
#     %14 = mhlo.add %11, %13 : tensor<2xui32> loc(#loc9)
#     %15 = mhlo.constant dense<13> : tensor<ui32> loc(#loc8)
#     %16 = "mhlo.broadcast_in_dim"(%15) {broadcast_dimensions = dense<> : tensor<0xi64>} : (tensor<ui32>) -> tensor<2xui32> loc(#loc10)
#     %17 = mhlo.shift_left %13, %16 : tensor<2xui32> loc(#loc10)
#     %18 = mhlo.constant dense<19> : tensor<ui32> loc(#loc8)
#     %19 = "mhlo.broadcast_in_dim"(%18) {broadcast_dimensions = dense<> : tensor<0xi64>} : (tensor<ui32>) -> tensor<2xui32> loc(#loc11)
#     %20 = mhlo.shift_right_logical %13, %19 : tensor<2xui32> loc(#loc11)
#     %21 = mhlo.or %17, %20 : tensor<2xui32> loc(#loc12)
#     %22 = mhlo.xor %14, %21 : tensor<2xui32> loc(#loc7)
#     %23 = mhlo.add %14, %22 : tensor<2xui32> loc(#loc9)
#     %24 = mhlo.constant dense<15> : tensor<ui32> loc(#loc8)
#     %25 = "mhlo.broadcast_in_dim"(%24) {broadcast_dimensions = dense<> : tensor<0xi64>} : (tensor<ui32>) -> tensor<2xui32> loc(#loc10)
#     %26 = mhlo.shift_left %22, %25 : tensor<2xui32> loc(#loc10)
#     %27 = mhlo.constant dense<17> : tensor<ui32> loc(#loc8)
#     %28 = "mhlo.broadcast_in_dim"(%27) {broadcast_dimensions = dense<> : tensor<0xi64>} : (tensor<ui32>) -> tensor<2xui32> loc(#loc11)
#     %29 = mhlo.shift_right_logical %22, %28 : tensor<2xui32> loc(#loc11)
#     %30 = mhlo.or %26, %29 : tensor<2xui32> loc(#loc12)
#     %31 = mhlo.xor %23, %30 : tensor<2xui32> loc(#loc7)
#     %32 = mhlo.add %23, %31 : tensor<2xui32> loc(#loc9)
#     %33 = mhlo.constant dense<26> : tensor<ui32> loc(#loc8)
#     %34 = "mhlo.broadcast_in_dim"(%33) {broadcast_dimensions = dense<> : tensor<0xi64>} : (tensor<ui32>) -> tensor<2xui32> loc(#loc10)
#     %35 = mhlo.shift_left %31, %34 : tensor<2xui32> loc(#loc10)
#     %36 = mhlo.constant dense<6> : tensor<ui32> loc(#loc8)
#     %37 = "mhlo.broadcast_in_dim"(%36) {broadcast_dimensions = dense<> : tensor<0xi64>} : (tensor<ui32>) -> tensor<2xui32> loc(#loc11)
#     %38 = mhlo.shift_right_logical %31, %37 : tensor<2xui32> loc(#loc11)
#     %39 = mhlo.or %35, %38 : tensor<2xui32> loc(#loc12)
#     %40 = mhlo.xor %32, %39 : tensor<2xui32> loc(#loc7)
#     %41 = mhlo.add %32, %40 : tensor<2xui32> loc(#loc9)
#     %42 = mhlo.constant dense<6> : tensor<ui32> loc(#loc8)
#     %43 = "mhlo.broadcast_in_dim"(%42) {broadcast_dimensions = dense<> : tensor<0xi64>} : (tensor<ui32>) -> tensor<2xui32> loc(#loc10)
#     %44 = mhlo.shift_left %40, %43 : tensor<2xui32> loc(#loc10)
#     %45 = mhlo.constant dense<26> : tensor<ui32> loc(#loc8)
#     %46 = "mhlo.broadcast_in_dim"(%45) {broadcast_dimensions = dense<> : tensor<0xi64>} : (tensor<ui32>) -> tensor<2xui32> loc(#loc11)
#     %47 = mhlo.shift_right_logical %40, %46 : tensor<2xui32> loc(#loc11)
#     %48 = mhlo.or %44, %47 : tensor<2xui32> loc(#loc12)
#     %49 = mhlo.xor %41, %48 : tensor<2xui32> loc(#loc7)
#     %50 = "mhlo.broadcast_in_dim"(%4) {broadcast_dimensions = dense<> : tensor<0xi64>} : (tensor<ui32>) -> tensor<2xui32> loc(#loc9)
#     %51 = mhlo.add %41, %50 : tensor<2xui32> loc(#loc9)
#     %52 = "mhlo.broadcast_in_dim"(%9) {broadcast_dimensions = dense<> : tensor<0xi64>} : (tensor<ui32>) -> tensor<2xui32> loc(#loc9)
#     %53 = mhlo.add %49, %52 : tensor<2xui32> loc(#loc9)
#     %54 = mhlo.constant dense<1> : tensor<ui32> loc(#loc8)
#     %55 = "mhlo.broadcast_in_dim"(%54) {broadcast_dimensions = dense<> : tensor<0xi64>} : (tensor<ui32>) -> tensor<2xui32> loc(#loc9)
#     %56 = mhlo.add %53, %55 : tensor<2xui32> loc(#loc9)
#     %57 = mhlo.add %51, %56 : tensor<2xui32> loc(#loc9)
#     %58 = mhlo.constant dense<17> : tensor<ui32> loc(#loc8)
#     %59 = "mhlo.broadcast_in_dim"(%58) {broadcast_dimensions = dense<> : tensor<0xi64>} : (tensor<ui32>) -> tensor<2xui32> loc(#loc10)
#     %60 = mhlo.shift_left %56, %59 : tensor<2xui32> loc(#loc10)
#     %61 = mhlo.constant dense<15> : tensor<ui32> loc(#loc8)
#     %62 = "mhlo.broadcast_in_dim"(%61) {broadcast_dimensions = dense<> : tensor<0xi64>} : (tensor<ui32>) -> tensor<2xui32> loc(#loc11)
#     %63 = mhlo.shift_right_logical %56, %62 : tensor<2xui32> loc(#loc11)
#     %64 = mhlo.or %60, %63 : tensor<2xui32> loc(#loc12)
#     %65 = mhlo.xor %57, %64 : tensor<2xui32> loc(#loc7)
#     %66 = mhlo.add %57, %65 : tensor<2xui32> loc(#loc9)
#     %67 = mhlo.constant dense<29> : tensor<ui32> loc(#loc8)
#     %68 = "mhlo.broadcast_in_dim"(%67) {broadcast_dimensions = dense<> : tensor<0xi64>} : (tensor<ui32>) -> tensor<2xui32> loc(#loc10)
#     %69 = mhlo.shift_left %65, %68 : tensor<2xui32> loc(#loc10)
#     %70 = mhlo.constant dense<3> : tensor<ui32> loc(#loc8)
#     %71 = "mhlo.broadcast_in_dim"(%70) {broadcast_dimensions = dense<> : tensor<0xi64>} : (tensor<ui32>) -> tensor<2xui32> loc(#loc11)
#     %72 = mhlo.shift_right_logical %65, %71 : tensor<2xui32> loc(#loc11)
#     %73 = mhlo.or %69, %72 : tensor<2xui32> loc(#loc12)
#     %74 = mhlo.xor %66, %73 : tensor<2xui32> loc(#loc7)
#     %75 = mhlo.add %66, %74 : tensor<2xui32> loc(#loc9)
#     %76 = mhlo.constant dense<16> : tensor<ui32> loc(#loc8)
#     %77 = "mhlo.broadcast_in_dim"(%76) {broadcast_dimensions = dense<> : tensor<0xi64>} : (tensor<ui32>) -> tensor<2xui32> loc(#loc10)
#     %78 = mhlo.shift_left %74, %77 : tensor<2xui32> loc(#loc10)
#     %79 = mhlo.constant dense<16> : tensor<ui32> loc(#loc8)
#     %80 = "mhlo.broadcast_in_dim"(%79) {broadcast_dimensions = dense<> : tensor<0xi64>} : (tensor<ui32>) -> tensor<2xui32> loc(#loc11)
#     %81 = mhlo.shift_right_logical %74, %80 : tensor<2xui32> loc(#loc11)
#     %82 = mhlo.or %78, %81 : tensor<2xui32> loc(#loc12)
#     %83 = mhlo.xor %75, %82 : tensor<2xui32> loc(#loc7)
#     %84 = mhlo.add %75, %83 : tensor<2xui32> loc(#loc9)
#     %85 = mhlo.constant dense<24> : tensor<ui32> loc(#loc8)
#     %86 = "mhlo.broadcast_in_dim"(%85) {broadcast_dimensions = dense<> : tensor<0xi64>} : (tensor<ui32>) -> tensor<2xui32> loc(#loc10)
#     %87 = mhlo.shift_left %83, %86 : tensor<2xui32> loc(#loc10)
#     %88 = mhlo.constant dense<8> : tensor<ui32> loc(#loc8)
#     %89 = "mhlo.broadcast_in_dim"(%88) {broadcast_dimensions = dense<> : tensor<0xi64>} : (tensor<ui32>) -> tensor<2xui32> loc(#loc11)
#     %90 = mhlo.shift_right_logical %83, %89 : tensor<2xui32> loc(#loc11)
#     %91 = mhlo.or %87, %90 : tensor<2xui32> loc(#loc12)
#     %92 = mhlo.xor %84, %91 : tensor<2xui32> loc(#loc7)
#     %93 = "mhlo.broadcast_in_dim"(%9) {broadcast_dimensions = dense<> : tensor<0xi64>} : (tensor<ui32>) -> tensor<2xui32> loc(#loc9)
#     %94 = mhlo.add %84, %93 : tensor<2xui32> loc(#loc9)
#     %95 = "mhlo.broadcast_in_dim"(%2) {broadcast_dimensions = dense<> : tensor<0xi64>} : (tensor<ui32>) -> tensor<2xui32> loc(#loc9)
#     %96 = mhlo.add %92, %95 : tensor<2xui32> loc(#loc9)
#     %97 = mhlo.constant dense<2> : tensor<ui32> loc(#loc8)
#     %98 = "mhlo.broadcast_in_dim"(%97) {broadcast_dimensions = dense<> : tensor<0xi64>} : (tensor<ui32>) -> tensor<2xui32> loc(#loc9)
#     %99 = mhlo.add %96, %98 : tensor<2xui32> loc(#loc9)
#     %100 = mhlo.add %94, %99 : tensor<2xui32> loc(#loc9)
#     %101 = mhlo.constant dense<13> : tensor<ui32> loc(#loc8)
#     %102 = "mhlo.broadcast_in_dim"(%101) {broadcast_dimensions = dense<> : tensor<0xi64>} : (tensor<ui32>) -> tensor<2xui32> loc(#loc10)
#     %103 = mhlo.shift_left %99, %102 : tensor<2xui32> loc(#loc10)
#     %104 = mhlo.constant dense<19> : tensor<ui32> loc(#loc8)
#     %105 = "mhlo.broadcast_in_dim"(%104) {broadcast_dimensions = dense<> : tensor<0xi64>} : (tensor<ui32>) -> tensor<2xui32> loc(#loc11)
#     %106 = mhlo.shift_right_logical %99, %105 : tensor<2xui32> loc(#loc11)
#     %107 = mhlo.or %103, %106 : tensor<2xui32> loc(#loc12)
#     %108 = mhlo.xor %100, %107 : tensor<2xui32> loc(#loc7)
#     %109 = mhlo.add %100, %108 : tensor<2xui32> loc(#loc9)
#     %110 = mhlo.constant dense<15> : tensor<ui32> loc(#loc8)
#     %111 = "mhlo.broadcast_in_dim"(%110) {broadcast_dimensions = dense<> : tensor<0xi64>} : (tensor<ui32>) -> tensor<2xui32> loc(#loc10)
#     %112 = mhlo.shift_left %108, %111 : tensor<2xui32> loc(#loc10)
#     %113 = mhlo.constant dense<17> : tensor<ui32> loc(#loc8)
#     %114 = "mhlo.broadcast_in_dim"(%113) {broadcast_dimensions = dense<> : tensor<0xi64>} : (tensor<ui32>) -> tensor<2xui32> loc(#loc11)
#     %115 = mhlo.shift_right_logical %108, %114 : tensor<2xui32> loc(#loc11)
#     %116 = mhlo.or %112, %115 : tensor<2xui32> loc(#loc12)
#     %117 = mhlo.xor %109, %116 : tensor<2xui32> loc(#loc7)
#     %118 = mhlo.add %109, %117 : tensor<2xui32> loc(#loc9)
#     %119 = mhlo.constant dense<26> : tensor<ui32> loc(#loc8)
#     %120 = "mhlo.broadcast_in_dim"(%119) {broadcast_dimensions = dense<> : tensor<0xi64>} : (tensor<ui32>) -> tensor<2xui32> loc(#loc10)
#     %121 = mhlo.shift_left %117, %120 : tensor<2xui32> loc(#loc10)
#     %122 = mhlo.constant dense<6> : tensor<ui32> loc(#loc8)
#     %123 = "mhlo.broadcast_in_dim"(%122) {broadcast_dimensions = dense<> : tensor<0xi64>} : (tensor<ui32>) -> tensor<2xui32> loc(#loc11)
#     %124 = mhlo.shift_right_logical %117, %123 : tensor<2xui32> loc(#loc11)
#     %125 = mhlo.or %121, %124 : tensor<2xui32> loc(#loc12)
#     %126 = mhlo.xor %118, %125 : tensor<2xui32> loc(#loc7)
#     %127 = mhlo.add %118, %126 : tensor<2xui32> loc(#loc9)
#     %128 = mhlo.constant dense<6> : tensor<ui32> loc(#loc8)
#     %129 = "mhlo.broadcast_in_dim"(%128) {broadcast_dimensions = dense<> : tensor<0xi64>} : (tensor<ui32>) -> tensor<2xui32> loc(#loc10)
#     %130 = mhlo.shift_left %126, %129 : tensor<2xui32> loc(#loc10)
#     %131 = mhlo.constant dense<26> : tensor<ui32> loc(#loc8)
#     %132 = "mhlo.broadcast_in_dim"(%131) {broadcast_dimensions = dense<> : tensor<0xi64>} : (tensor<ui32>) -> tensor<2xui32> loc(#loc11)
#     %133 = mhlo.shift_right_logical %126, %132 : tensor<2xui32> loc(#loc11)
#     %134 = mhlo.or %130, %133 : tensor<2xui32> loc(#loc12)
#     %135 = mhlo.xor %127, %134 : tensor<2xui32> loc(#loc7)
#     %136 = "mhlo.broadcast_in_dim"(%2) {broadcast_dimensions = dense<> : tensor<0xi64>} : (tensor<ui32>) -> tensor<2xui32> loc(#loc9)
#     %137 = mhlo.add %127, %136 : tensor<2xui32> loc(#loc9)
#     %138 = "mhlo.broadcast_in_dim"(%4) {broadcast_dimensions = dense<> : tensor<0xi64>} : (tensor<ui32>) -> tensor<2xui32> loc(#loc9)
#     %139 = mhlo.add %135, %138 : tensor<2xui32> loc(#loc9)
#     %140 = mhlo.constant dense<3> : tensor<ui32> loc(#loc8)
#     %141 = "mhlo.broadcast_in_dim"(%140) {broadcast_dimensions = dense<> : tensor<0xi64>} : (tensor<ui32>) -> tensor<2xui32> loc(#loc9)
#     %142 = mhlo.add %139, %141 : tensor<2xui32> loc(#loc9)
#     %143 = mhlo.add %137, %142 : tensor<2xui32> loc(#loc9)
#     %144 = mhlo.constant dense<17> : tensor<ui32> loc(#loc8)
#     %145 = "mhlo.broadcast_in_dim"(%144) {broadcast_dimensions = dense<> : tensor<0xi64>} : (tensor<ui32>) -> tensor<2xui32> loc(#loc10)
#     %146 = mhlo.shift_left %142, %145 : tensor<2xui32> loc(#loc10)
#     %147 = mhlo.constant dense<15> : tensor<ui32> loc(#loc8)
#     %148 = "mhlo.broadcast_in_dim"(%147) {broadcast_dimensions = dense<> : tensor<0xi64>} : (tensor<ui32>) -> tensor<2xui32> loc(#loc11)
#     %149 = mhlo.shift_right_logical %142, %148 : tensor<2xui32> loc(#loc11)
#     %150 = mhlo.or %146, %149 : tensor<2xui32> loc(#loc12)
#     %151 = mhlo.xor %143, %150 : tensor<2xui32> loc(#loc7)
#     %152 = mhlo.add %143, %151 : tensor<2xui32> loc(#loc9)
#     %153 = mhlo.constant dense<29> : tensor<ui32> loc(#loc8)
#     %154 = "mhlo.broadcast_in_dim"(%153) {broadcast_dimensions = dense<> : tensor<0xi64>} : (tensor<ui32>) -> tensor<2xui32> loc(#loc10)
#     %155 = mhlo.shift_left %151, %154 : tensor<2xui32> loc(#loc10)
#     %156 = mhlo.constant dense<3> : tensor<ui32> loc(#loc8)
#     %157 = "mhlo.broadcast_in_dim"(%156) {broadcast_dimensions = dense<> : tensor<0xi64>} : (tensor<ui32>) -> tensor<2xui32> loc(#loc11)
#     %158 = mhlo.shift_right_logical %151, %157 : tensor<2xui32> loc(#loc11)
#     %159 = mhlo.or %155, %158 : tensor<2xui32> loc(#loc12)
#     %160 = mhlo.xor %152, %159 : tensor<2xui32> loc(#loc7)
#     %161 = mhlo.add %152, %160 : tensor<2xui32> loc(#loc9)
#     %162 = mhlo.constant dense<16> : tensor<ui32> loc(#loc8)
#     %163 = "mhlo.broadcast_in_dim"(%162) {broadcast_dimensions = dense<> : tensor<0xi64>} : (tensor<ui32>) -> tensor<2xui32> loc(#loc10)
#     %164 = mhlo.shift_left %160, %163 : tensor<2xui32> loc(#loc10)
#     %165 = mhlo.constant dense<16> : tensor<ui32> loc(#loc8)
#     %166 = "mhlo.broadcast_in_dim"(%165) {broadcast_dimensions = dense<> : tensor<0xi64>} : (tensor<ui32>) -> tensor<2xui32> loc(#loc11)
#     %167 = mhlo.shift_right_logical %160, %166 : tensor<2xui32> loc(#loc11)
#     %168 = mhlo.or %164, %167 : tensor<2xui32> loc(#loc12)
#     %169 = mhlo.xor %161, %168 : tensor<2xui32> loc(#loc7)
#     %170 = mhlo.add %161, %169 : tensor<2xui32> loc(#loc9)
#     %171 = mhlo.constant dense<24> : tensor<ui32> loc(#loc8)
#     %172 = "mhlo.broadcast_in_dim"(%171) {broadcast_dimensions = dense<> : tensor<0xi64>} : (tensor<ui32>) -> tensor<2xui32> loc(#loc10)
#     %173 = mhlo.shift_left %169, %172 : tensor<2xui32> loc(#loc10)
#     %174 = mhlo.constant dense<8> : tensor<ui32> loc(#loc8)
#     %175 = "mhlo.broadcast_in_dim"(%174) {broadcast_dimensions = dense<> : tensor<0xi64>} : (tensor<ui32>) -> tensor<2xui32> loc(#loc11)
#     %176 = mhlo.shift_right_logical %169, %175 : tensor<2xui32> loc(#loc11)
#     %177 = mhlo.or %173, %176 : tensor<2xui32> loc(#loc12)
#     %178 = mhlo.xor %170, %177 : tensor<2xui32> loc(#loc7)
#     %179 = "mhlo.broadcast_in_dim"(%4) {broadcast_dimensions = dense<> : tensor<0xi64>} : (tensor<ui32>) -> tensor<2xui32> loc(#loc9)
#     %180 = mhlo.add %170, %179 : tensor<2xui32> loc(#loc9)
#     %181 = "mhlo.broadcast_in_dim"(%9) {broadcast_dimensions = dense<> : tensor<0xi64>} : (tensor<ui32>) -> tensor<2xui32> loc(#loc9)
#     %182 = mhlo.add %178, %181 : tensor<2xui32> loc(#loc9)
#     %183 = mhlo.constant dense<4> : tensor<ui32> loc(#loc8)
#     %184 = "mhlo.broadcast_in_dim"(%183) {broadcast_dimensions = dense<> : tensor<0xi64>} : (tensor<ui32>) -> tensor<2xui32> loc(#loc9)
#     %185 = mhlo.add %182, %184 : tensor<2xui32> loc(#loc9)
#     %186 = mhlo.add %180, %185 : tensor<2xui32> loc(#loc9)
#     %187 = mhlo.constant dense<13> : tensor<ui32> loc(#loc8)
#     %188 = "mhlo.broadcast_in_dim"(%187) {broadcast_dimensions = dense<> : tensor<0xi64>} : (tensor<ui32>) -> tensor<2xui32> loc(#loc10)
#     %189 = mhlo.shift_left %185, %188 : tensor<2xui32> loc(#loc10)
#     %190 = mhlo.constant dense<19> : tensor<ui32> loc(#loc8)
#     %191 = "mhlo.broadcast_in_dim"(%190) {broadcast_dimensions = dense<> : tensor<0xi64>} : (tensor<ui32>) -> tensor<2xui32> loc(#loc11)
#     %192 = mhlo.shift_right_logical %185, %191 : tensor<2xui32> loc(#loc11)
#     %193 = mhlo.or %189, %192 : tensor<2xui32> loc(#loc12)
#     %194 = mhlo.xor %186, %193 : tensor<2xui32> loc(#loc7)
#     %195 = mhlo.add %186, %194 : tensor<2xui32> loc(#loc9)
#     %196 = mhlo.constant dense<15> : tensor<ui32> loc(#loc8)
#     %197 = "mhlo.broadcast_in_dim"(%196) {broadcast_dimensions = dense<> : tensor<0xi64>} : (tensor<ui32>) -> tensor<2xui32> loc(#loc10)
#     %198 = mhlo.shift_left %194, %197 : tensor<2xui32> loc(#loc10)
#     %199 = mhlo.constant dense<17> : tensor<ui32> loc(#loc8)
#     %200 = "mhlo.broadcast_in_dim"(%199) {broadcast_dimensions = dense<> : tensor<0xi64>} : (tensor<ui32>) -> tensor<2xui32> loc(#loc11)
#     %201 = mhlo.shift_right_logical %194, %200 : tensor<2xui32> loc(#loc11)
#     %202 = mhlo.or %198, %201 : tensor<2xui32> loc(#loc12)
#     %203 = mhlo.xor %195, %202 : tensor<2xui32> loc(#loc7)
#     %204 = mhlo.add %195, %203 : tensor<2xui32> loc(#loc9)
#     %205 = mhlo.constant dense<26> : tensor<ui32> loc(#loc8)
#     %206 = "mhlo.broadcast_in_dim"(%205) {broadcast_dimensions = dense<> : tensor<0xi64>} : (tensor<ui32>) -> tensor<2xui32> loc(#loc10)
#     %207 = mhlo.shift_left %203, %206 : tensor<2xui32> loc(#loc10)
#     %208 = mhlo.constant dense<6> : tensor<ui32> loc(#loc8)
#     %209 = "mhlo.broadcast_in_dim"(%208) {broadcast_dimensions = dense<> : tensor<0xi64>} : (tensor<ui32>) -> tensor<2xui32> loc(#loc11)
#     %210 = mhlo.shift_right_logical %203, %209 : tensor<2xui32> loc(#loc11)
#     %211 = mhlo.or %207, %210 : tensor<2xui32> loc(#loc12)
#     %212 = mhlo.xor %204, %211 : tensor<2xui32> loc(#loc7)
#     %213 = mhlo.add %204, %212 : tensor<2xui32> loc(#loc9)
#     %214 = mhlo.constant dense<6> : tensor<ui32> loc(#loc8)
#     %215 = "mhlo.broadcast_in_dim"(%214) {broadcast_dimensions = dense<> : tensor<0xi64>} : (tensor<ui32>) -> tensor<2xui32> loc(#loc10)
#     %216 = mhlo.shift_left %212, %215 : tensor<2xui32> loc(#loc10)
#     %217 = mhlo.constant dense<26> : tensor<ui32> loc(#loc8)
#     %218 = "mhlo.broadcast_in_dim"(%217) {broadcast_dimensions = dense<> : tensor<0xi64>} : (tensor<ui32>) -> tensor<2xui32> loc(#loc11)
#     %219 = mhlo.shift_right_logical %212, %218 : tensor<2xui32> loc(#loc11)
#     %220 = mhlo.or %216, %219 : tensor<2xui32> loc(#loc12)
#     %221 = mhlo.xor %213, %220 : tensor<2xui32> loc(#loc7)
#     %222 = "mhlo.broadcast_in_dim"(%9) {broadcast_dimensions = dense<> : tensor<0xi64>} : (tensor<ui32>) -> tensor<2xui32> loc(#loc9)
#     %223 = mhlo.add %213, %222 : tensor<2xui32> loc(#loc9)
#     %224 = "mhlo.broadcast_in_dim"(%2) {broadcast_dimensions = dense<> : tensor<0xi64>} : (tensor<ui32>) -> tensor<2xui32> loc(#loc9)
#     %225 = mhlo.add %221, %224 : tensor<2xui32> loc(#loc9)
#     %226 = mhlo.constant dense<5> : tensor<ui32> loc(#loc8)
#     %227 = "mhlo.broadcast_in_dim"(%226) {broadcast_dimensions = dense<> : tensor<0xi64>} : (tensor<ui32>) -> tensor<2xui32> loc(#loc9)
#     %228 = mhlo.add %225, %227 : tensor<2xui32> loc(#loc9)
#     %229 = "mhlo.concatenate"(%223, %228) {dimension = 0 : i64} : (tensor<2xui32>, tensor<2xui32>) -> tensor<4xui32> loc(#loc13)
#     %230 = "mhlo.reshape"(%229) : (tensor<4xui32>) -> tensor<2x2xui32> loc(#loc14)
#     return %230 : tensor<2x2xui32> loc(#loc0)
#   } loc(#loc0)
#   } loc(#loc0)
# #loc1 = loc("jit(_threefry_split)/jit(main)/iota[dtype=uint32 shape=(4,) dimension=0]"("/Users/birch/git/dalle-playground/backend/dalle_model.py":92:1))
# #loc2 = loc("jit(_threefry_split)/jit(main)/slice[start_indices=(0,) limit_indices=(1,) strides=(1,)]"("/Users/birch/git/dalle-playground/backend/dalle_model.py":92:1))
# #loc3 = loc("jit(_threefry_split)/jit(main)/squeeze[dimensions=(0,)]"("/Users/birch/git/dalle-playground/backend/dalle_model.py":92:1))
# #loc4 = loc("jit(_threefry_split)/jit(main)/slice[start_indices=(1,) limit_indices=(2,) strides=(1,)]"("/Users/birch/git/dalle-playground/backend/dalle_model.py":92:1))
# #loc5 = loc("jit(_threefry_split)/jit(main)/slice[start_indices=(0,) limit_indices=(2,) strides=None]"("/Users/birch/git/dalle-playground/backend/dalle_model.py":92:1))
# #loc6 = loc("jit(_threefry_split)/jit(main)/slice[start_indices=(2,) limit_indices=(4,) strides=None]"("/Users/birch/git/dalle-playground/backend/dalle_model.py":92:1))
# #loc7 = loc("jit(_threefry_split)/jit(main)/xor"("/Users/birch/git/dalle-playground/backend/dalle_model.py":92:1))
# #loc8 = loc("jit(_threefry_split)/jit(main)/threefry2x32"("/Users/birch/git/dalle-playground/backend/dalle_model.py":92:1))
# #loc9 = loc("jit(_threefry_split)/jit(main)/add"("/Users/birch/git/dalle-playground/backend/dalle_model.py":92:1))
# #loc10 = loc("jit(_threefry_split)/jit(main)/shift_left"("/Users/birch/git/dalle-playground/backend/dalle_model.py":92:1))
# #loc11 = loc("jit(_threefry_split)/jit(main)/shift_right_logical"("/Users/birch/git/dalle-playground/backend/dalle_model.py":92:1))
# #loc12 = loc("jit(_threefry_split)/jit(main)/or"("/Users/birch/git/dalle-playground/backend/dalle_model.py":92:1))
# #loc13 = loc("jit(_threefry_split)/jit(main)/concatenate[dimension=0]"("/Users/birch/git/dalle-playground/backend/dalle_model.py":92:1))
# #loc14 = loc("jit(_threefry_split)/jit(main)/reshape[new_sizes=(2, 2) dimensions=None]"("/Users/birch/git/dalle-playground/backend/dalle_model.py":92:1))
# """

CODE = """
#loc0 = loc(unknown)
module @jit_prim_fun.0 {
    func public @main(%arg0: tensor<i32> loc(unknown), %arg1: tensor<i32> loc(unknown)) -> tensor<i32> {
      %0 = mhlo.shift_right_logical %arg0, %arg1 : tensor<i32> loc(#loc1)
    return %0 : tensor<i32> loc(#loc0)
  } loc(#loc0)
} loc(#loc0)
#loc1 = loc("jit(shift_right_logical)/jit(main)/shift_right_logical"("/Users/birch/git/dalle-playground/backend/dalle/lib/python3.9/site-packages/transformers/modeling_flax_utils.py":205:1))
"""

# compiler.CompilerOptions("--mlir-print-ir-after-failure")
# compiler.
# rt.flags.parse_flags("mlir-print-ir-after-failure")
# rt.flags.parse_flags("-iree-flow-demote-i64-to-i32")
# rt.flags.parse_flags("--iree_v=1")

# extra_args = []
# extra_args = ["--mlir-print-ir-after-failure"]
# realistically I'd recommend the following arguments too
# https://github.com/nod-ai/SHARK/blob/1186d7c58e6046aea6a6115c608dbd77728e7aca/shark/iree_utils.py#L93-L96
# but the problem reproduces without them anyway
# extra_args = [
# "--mlir-print-ir-after-failure",
# "--iree-llvm-target-triple=arm64-apple-darwin21.5.0",
# "--iree-flow-demote-i64-to-i32",
# "--iree-vulkan-target-triple=m1-moltenvk-macos",
# "--iree-llvm-target-cpu-features=host",
# "--iree-mhlo-demote-i64-to-i32=false"]

compiler.compile_str(CODE, target_backends=["dylib"], input_type="mhlo")